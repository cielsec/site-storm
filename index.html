<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#050707" />
  <meta name="description" content="Storm Central: hub dark neon para operações, pesquisa e engenharia ofensiva." />
  <title>Storm Central</title>

  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet" />

  <link rel="stylesheet" href="styles.css" />
  <script defer src="app.js"></script>
</head>
<body>
  <div class="bg" aria-hidden="true"></div>
  <div class="grid" aria-hidden="true"></div>
  <div class="glow" aria-hidden="true"></div>
  <div class="cursor-dot" aria-hidden="true"></div>
  <div class="cursor-ring" aria-hidden="true"></div>

  <main class="shell">
    <section class="screen hero-screen is-active" id="hero">
      <div class="hero-core">
        <div class="hero-logo" aria-hidden="true">
          <svg viewBox="0 0 160 160" role="img" aria-label="Storm Central">
            <polygon points="80,10 150,50 150,110 80,150 10,110 10,50" />
            <polyline points="80,28 130,60 130,100 80,132 30,100 30,60 80,28" />
            <line x1="80" y1="28" x2="80" y2="132" />
          </svg>
        </div>
        <h1 class="hero-title">STORM CENTRAL</h1>
        <div class="hero-quote">
          <p>"Precisão silenciosa, impacto absoluto."</p>
          <span>— Diretriz Operacional</span>
        </div>
        <div class="hero-line" aria-hidden="true"></div>
        <p class="hero-welcome">Bem-vindo ao StormCentral.</p>
        <button class="btn btn-primary" id="enter-btn" type="button">ENTRAR</button>
      </div>
    </section>

    <section class="screen hub-screen" id="hub" aria-hidden="true">
      <header class="hub-header">
        <div>
          <p class="eyebrow">Painel Central</p>
          <h2>Operações, pesquisa e inteligência ofensiva.</h2>
        </div>
        <div class="hub-line" aria-hidden="true"></div>
      </header>

      <div class="hub-layout">
        <nav class="hub-menu" aria-label="Seções principais">
          <button class="hub-btn is-active" data-panel="grupo" type="button">
            <span class="icon">◎</span>
            Grupo
          </button>
          <button class="hub-btn" data-panel="ferramentas" type="button">
            <span class="icon">⌁</span>
            Ferramentas
          </button>
          <button class="hub-btn" data-panel="artigos" type="button">
            <span class="icon">⌬</span>
            Artigos
          </button>
          <button class="hub-btn" data-panel="suporte" type="button">
            <span class="icon">◇</span>
            Suporte
          </button>
          <button class="hub-btn" data-panel="projetos" type="button">
            <span class="icon">⬡</span>
            Projetos
          </button>
        </nav>

        <div class="hub-panels">
          <article class="hub-panel is-active" id="panel-grupo">
            <h3>Grupo</h3>
            <p>
              Núcleo multidisciplinar focado em engenharia reversa, inteligência de ameaças e
              resposta a incidentes com metodologia operacional rigorosa.
            </p>
            <ul>
              <li>Rotinas de laboratório e validação de TTPs.</li>
              <li>Documentação técnica para times internos.</li>
              <li>Monitoramento contínuo de superfícies críticas.</li>
            </ul>
          </article>
          <article class="hub-panel" id="panel-ferramentas">
            <h3>Ferramentas</h3>
            <p>
              Toolkit dedicado a coleta, triagem e enriquecimento de dados em operações de campo,
              com automação segura e auditável.
            </p>
            <ul>
              <li>Recon e enumeração de ativos em múltiplas camadas.</li>
              <li>Pipeline de análise com alertas por prioridade.</li>
              <li>Playbooks versionados e rastreáveis.</li>
            </ul>
          </article>
          <article class="hub-panel" id="panel-artigos">
            <h3>Artigos</h3>
            <p>
              Pesquisa aplicada em defesa ofensiva: estudos de caso, lições aprendidas e revisão de
              operações com foco em mitigação.
            </p>
            <ul>
              <li>Briefings de inteligência e tendências.</li>
              <li>Arquiteturas seguras e hardening.</li>
              <li>Guia para análises forenses rápidas.</li>
            </ul>
          </article>
          <article class="hub-panel" id="panel-suporte">
            <h3>Suporte</h3>
            <p>
              Canal direto para coordenação tática, triagem de incidentes e implementação de
              contramedidas em produção.
            </p>
            <ul>
              <li>Onboarding seguro para equipes.</li>
              <li>Resposta assistida e pós-incidente.</li>
              <li>Consultoria técnica e treinamento.</li>
            </ul>
          </article>
          <article class="hub-panel" id="panel-projetos">
            <h3>Projetos</h3>
            <p>
              Portfólio de iniciativas open-source e laboratórios internos voltados a segurança
              ofensiva e engenharia de dados.
            </p>
            <ul>
              <li>Frameworks de coleta modular.</li>
              <li>Dashboards de visibilidade em tempo real.</li>
              <li>Testes de intrusão controlados.</li>
            </ul>
          </article>
        </div>
      </div>

      <section class="projects" id="projects">
        <div class="projects-header">
          <p class="eyebrow">Open-source | Forense | Pentest | Code</p>
          <h2>Projetos ativos</h2>
        </div>

        <div class="projects-grid">
          <article class="project-card">
            <div class="project-head">
              <h3>havijpy_sqlmap_gui.py</h3>
              <p>Interface gráfica que executa SQLmap e exibe o output em tempo real.</p>
            </div>
            <button class="btn btn-ghost project-toggle" type="button">Mostrar projeto</button>
            <div class="project-body">
              <div class="project-frame">
                <img src="https://images.unsplash.com/photo-1518770660439-4636190af475?auto=format&fit=crop&w=900&q=80" alt="Interface de monitoramento de execução" loading="lazy" />
              </div>
              <p>
                GUI em PyQt com controle de execução, logs instantâneos e suporte a parâmetros
                personalizados para operações de análise.
              </p>
              <pre class="code-block"><code>#!/usr/bin/env python3
import sys, subprocess, threading
from PyQt6.QtWidgets import QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLineEdit, QPushButton, QTextEdit, QLabel

class App(QWidget):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("HavijPy - SQLmap GUI")
        self.proc = None

        self.url = QLineEdit()
        self.url.setPlaceholderText("URL alvo (ex: https://site.com/item.php?id=1)")
        self.args = QLineEdit()
        self.args.setPlaceholderText("Args extras (ex: --dbs --batch)")
        self.log = QTextEdit(); self.log.setReadOnly(True)

        run = QPushButton("Rodar"); stop = QPushButton("Parar")
        run.clicked.connect(self.run_sqlmap); stop.clicked.connect(self.stop_sqlmap)

        top = QHBoxLayout(); top.addWidget(QLabel("URL:")); top.addWidget(self.url)
        mid = QHBoxLayout(); mid.addWidget(QLabel("Args:")); mid.addWidget(self.args)

        btns = QHBoxLayout(); btns.addWidget(run); btns.addWidget(stop)

        layout = QVBoxLayout(self)
        layout.addLayout(top); layout.addLayout(mid); layout.addLayout(btns); layout.addWidget(self.log)

    def run_sqlmap(self):
        if self.proc: return
        u = self.url.text().strip()
        extra = self.args.text().strip().split() if self.args.text().strip() else []
        if not u:
            self.log.append("[-] Informe uma URL.")
            return
        cmd = ["sqlmap", "-u", u, "--batch"] + extra
        self.log.append("[*] " + " ".join(cmd))
        self.proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)

        def reader():
            for line in self.proc.stdout:
                self.log.append(line.rstrip())
            code = self.proc.wait()
            self.log.append(f"[+] Finalizado (exit={code})")
            self.proc = None

        threading.Thread(target=reader, daemon=True).start()

    def stop_sqlmap(self):
        if self.proc:
            self.proc.terminate()
            self.log.append("[*] Processo finalizado.")
            self.proc = None

if __name__ == "__main__":
    app = QApplication(sys.argv)
    w = App(); w.resize(900, 520); w.show()
    sys.exit(app.exec())
</code></pre>
              <p class="project-meta">Autor: Ciel Sec</p>
            </div>
          </article>

          <article class="project-card">
            <div class="project-head">
              <h3>pentest_central.py</h3>
              <p>Centraliza execuções de ferramentas e consolida logs por operação.</p>
            </div>
            <button class="btn btn-ghost project-toggle" type="button">Mostrar projeto</button>
            <div class="project-body">
              <div class="project-frame">
                <img src="https://images.unsplash.com/photo-1487058792275-0ad4aaf24ca7?auto=format&fit=crop&w=900&q=80" alt="Console de operações centralizadas" loading="lazy" />
              </div>
              <p>
                Orquestra fluxo de Nmap, Ffuf e Nuclei com logs versionados por data para auditoria.
              </p>
              <pre class="code-block"><code>#!/usr/bin/env python3
import os, subprocess, datetime, pathlib

BASE = pathlib.Path("logs")
BASE.mkdir(exist_ok=True)

def run(name, cmd):
    ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    out = BASE / f"{name}_{ts}.log"
    print(f"[+] {name} -> {out}")
    with out.open("w", encoding="utf-8") as f:
        p = subprocess.Popen(cmd, stdout=f, stderr=subprocess.STDOUT, text=True)
        return p.wait()

def main():
    print("1) Nmap\n2) Ffuf\n3) Nuclei")
    opt = input("> ").strip()
    if opt == "1":
        target = input("Alvo: ").strip()
        return run("nmap", ["nmap", "-sV", "-sC", "-Pn", target])
    if opt == "2":
        url = input("URL (com FUZZ): ").strip()
        word = input("Wordlist: ").strip()
        return run("ffuf", ["ffuf", "-u", url, "-w", word, "-mc", "all", "-fc", "404"])
    if opt == "3":
        target = input("Alvo: ").strip()
        return run("nuclei", ["nuclei", "-u", target])
    print("[-] Opção inválida.")
    return 1

if __name__ == "__main__":
    raise SystemExit(main())
</code></pre>
              <p class="project-meta">Autor: Ciel Sec</p>
            </div>
          </article>

          <article class="project-card">
            <div class="project-head">
              <h3>Cracker.sh</h3>
              <p>Automação de enumeração básica e organização de resultados.</p>
            </div>
            <button class="btn btn-ghost project-toggle" type="button">Mostrar projeto</button>
            <div class="project-body">
              <div class="project-frame">
                <img src="https://images.unsplash.com/photo-1510915228340-29c85a43dcfe?auto=format&fit=crop&w=900&q=80" alt="Pipeline de enumeração" loading="lazy" />
              </div>
              <p>
                Fluxo direto: subdomains, HTTP probe e análise com Nuclei, mantendo evidências
                organizadas por alvo.
              </p>
              <pre class="code-block"><code>#!/usr/bin/env bash
set -euo pipefail

TARGET="${1:-}"
OUT="recon_out"
mkdir -p "$OUT"

if [[ -z "$TARGET" ]]; then
  echo "Uso: $0 dominio.com"
  exit 1
fi

echo "[*] Subdomains"
subfinder -d "$TARGET" -silent | tee "$OUT/subs.txt" >/dev/null

echo "[*] HTTP probe"
httpx -l "$OUT/subs.txt" -silent -o "$OUT/live.txt"

echo "[*] Nuclei"
nuclei -l "$OUT/live.txt" -silent -o "$OUT/nuclei.txt"

echo "[+] Pronto: $OUT/"
</code></pre>
              <p class="project-meta">Autor: Ciel Sec</p>
            </div>
          </article>

          <article class="project-card">
            <div class="project-head">
              <h3>privesc_pack.sh</h3>
              <p>Coleta informações do host e executa helpers de enum/privesc.</p>
            </div>
            <button class="btn btn-ghost project-toggle" type="button">Mostrar projeto</button>
            <div class="project-body">
              <div class="project-frame">
                <img src="https://images.unsplash.com/photo-1550751827-4bd374c3f58b?auto=format&fit=crop&w=900&q=80" alt="Coleta de dados do host" loading="lazy" />
              </div>
              <p>
                Pacote de coleta com inventário do sistema, processos e permissões críticas para
                acelerar triagens de escalonamento.
              </p>
              <pre class="code-block"><code>#!/usr/bin/env bash
set -euo pipefail

OUT="privesc_out_$(date +%Y%m%d_%H%M%S)"
mkdir -p "$OUT"

echo "[*] Sistema" | tee "$OUT/info.txt"
uname -a | tee -a "$OUT/info.txt"
id | tee -a "$OUT/info.txt"
whoami | tee -a "$OUT/info.txt"

echo "[*] Processos" > "$OUT/ps.txt"
ps auxww > "$OUT/ps.txt"

echo "[*] SUID/SGID (pode demorar)"
find / -perm -4000 -type f 2>/dev/null > "$OUT/suid.txt"
find / -perm -2000 -type f 2>/dev/null > "$OUT/sgid.txt"

echo "[+] Saída em: $OUT/"
</code></pre>
              <p class="project-meta">Autor: Ciel Sec</p>
            </div>
          </article>

          <article class="project-card">
            <div class="project-head">
              <h3>WebDav Detector (ciel.pl)</h3>
              <p>Detecção e enumeração de WebDAV via OPTIONS com parsing avançado.</p>
            </div>
            <button class="btn btn-ghost project-toggle" type="button">Mostrar projeto</button>
            <div class="project-body">
              <div class="project-frame">
                <img src="https://images.unsplash.com/photo-1555066931-4365d14bab8c?auto=format&fit=crop&w=900&q=80" alt="Relatório de detecção WebDAV" loading="lazy" />
              </div>
              <p>
                Parser dedicado para URL, host e headers, com destaque de métodos suportados e
                indicadores de WebDAV para análise segura.
              </p>
              <pre class="code-block"><code>#!/usr/bin/perl
use strict;
use warnings;
use IO::Socket::INET;
use IO::Socket::SSL;
use Time::HiRes qw(time);

binmode(STDOUT, ":utf8");
my ($GREEN, $YELLOW, $CYAN, $RESET) = ("\\e[32m","\\e[33m","\\e[36m","\\e[0m");

sub banner {
  print $CYAN . "Ciel Sec - WebDAV Detector\\n" . $RESET;
}

sub usage {
  banner();
  print "${YELLOW}Uso:${RESET} perl $0 <URL> <user:pass>\\n";
  print "  ex: perl $0 https://host/webdav/ admin:admin\\n";
  exit 1;
}

sub parse_url {
  my ($url) = @_;
  if ($url =~ m{^(https?)://([^:/]+)(?::(\\d+))?(/.*)?$}i) {
    my $scheme = lc($1);
    my $host   = $2;
    my $port   = $3 || ($scheme eq 'https' ? 443 : 80);
    my $path   = $4 || '/';
    my $ssl    = ($scheme eq 'https') ? 1 : 0;
    $path .= '/' unless $path =~ /\\/$/ || $path =~ /\\.[a-z]+$/i;
    return ($host, $port, $path, $ssl);
  }
  return ();
}

sub create_socket {
  my ($host,$port,$ssl,$timeout) = @_;
  $timeout ||= 10;
  if ($ssl) {
    return IO::Socket::SSL->new(
      PeerHost => $host, PeerPort => $port,
      Timeout  => $timeout, SSL_verify_mode => 0
    );
  }
  return IO::Socket::INET->new(
    PeerHost => $host, PeerPort => $port,
    Timeout  => $timeout
  );
}

sub detect_webdav {
  my ($host,$port,$path,$ssl) = @_;
  print "\\n[+] OPTIONS para detectar WebDAV...\\n";
  my $sock = create_socket($host,$port,$ssl,10) or die "Falha ao conectar\\n";

  my $req = "OPTIONS $path HTTP/1.1\\r\\n".
            "Host: $host\\r\\n".
            "User-Agent: Mozilla/5.0\\r\\n".
            "Connection: close\\r\\n\\r\\n";

  print $sock $req;
  my $res = "";
  while (<$sock>) { $res .= $_; }
  close($sock);

  my ($server) = ($res =~ /Server:\\s*([^\\r\\n]+)/i);
  my ($allow)  = ($res =~ /Allow:\\s*([^\\r\\n]+)/i);
  my ($dav)    = ($res =~ /DAV:\\s*([^\\r\\n]+)/i);

  print $GREEN . "[✓] Server: " . ($server // "n/d") . $RESET . "\\n";
  print $GREEN . "[✓] Allow : " . ($allow  // "n/d") . $RESET . "\\n";
  print $GREEN . "[✓] DAV   : " . ($dav    // "n/d") . $RESET . "\\n";

  if (($allow // "") =~ /(PROPFIND|LOCK|COPY|MOVE|PUT)/i || defined $dav) {
    print $GREEN . "[✓] Indícios de WebDAV detectados.\\n" . $RESET;
  } else {
    print $YELLOW . "[!] WebDAV não anunciado explicitamente.\\n" . $RESET;
  }
}

# ---- main ----
@ARGV >= 2 or usage();
my ($host,$port,$path,$ssl) = parse_url($ARGV[0]);
$host or usage();
banner();
detect_webdav($host,$port,$path,$ssl);
</code></pre>
              <p class="project-meta">Autor: Ciel Sec</p>
            </div>
          </article>
        </div>
      </section>

      <footer class="site-footer">
        <p>Programado por StormCentral / Host by CielSec</p>
      </footer>
    </section>
  </main>
</body>
</html>
